//! # Fadroma

/// Import commonly used definitions that need to be available everywhere in the contract
#[macro_export] macro_rules! prelude {
    () => { use fadroma::scrt::cosmwasm_std::{
        Storage, Api, Querier, Extern, Env,
        HumanAddr, CanonicalAddr, Coin, Uint128,
        StdResult, StdError,
        InitResponse, HandleResponse, LogAttribute, Binary,
        CosmosMsg, BankMsg, WasmMsg, to_binary,
        log
    }; };
}

// The `message!` and `messages!` macros depend on derive macros from serde and schemars.
// This complicates the reexport via fadroma core due to how procedural macros resolve crates
// (see https://github.com/serde-rs/serde/issues/1465#issuecomment-458420543)
// The workaround at https://github.com/serde-rs/serde/issues/1465#issuecomment-800686252
// is automatically implemented in the `mod msg` generated by the `contract!` macro
// This is done automatically in the `mod msg` defined by the `contract!` macro. However if
// you use the message macros manually, it is up to you to implement a corresponding workaround.

/// Define an enum that implements the necessary traits
/// (de/serialization, schema generation, cloning, debug printing, equality comparison)
#[macro_export] macro_rules! message {
    ( $Msg:ident { $( $(#[$meta:meta])* $field:ident : $type:ty ),* } ) => {
        #[derive(Clone,Debug,PartialEq,serde::Serialize,serde::Deserialize,schemars::JsonSchema)]
        #[serde(rename_all="snake_case")]
        pub struct $Msg { $( $(#[$meta])* pub $field: $type ),* } } }

/// Define an enum with variants that implement the necessary traits
#[macro_export] macro_rules! messages {
    ( $( $Enum:ident {
        $( $(#[$meta:meta])* $Msg:ident { $(
            $(#[$field_meta:meta])* 
            $field:ident : $type:ty
        ),* } )*
    } )*
    ) => { $(
        #[derive(Clone,Debug,PartialEq,serde::Serialize,serde::Deserialize,schemars::JsonSchema)]
        #[serde(rename_all="snake_case")]
        pub enum $Enum { $(
            $(#[$meta])* $Msg { $(
                $(#[$field_meta])*
                $field : $type
            ),* }
        ),* } )*
    }
}

/// Define the state singleton.
// TODO: Support other shapes of state
#[macro_export] macro_rules! define_state_singleton {
    (
        $State:ident
        { $( $(#[$meta:meta])* $state_field:ident : $state_field_type:ty ),* }
    ) => {
        /// State singleton
        message!($State { $($(#[$meta])* $state_field:$state_field_type),* });
        use fadroma::scrt::cosmwasm_storage::{Singleton, singleton, ReadonlySingleton, singleton_read};
        pub static CONFIG_KEY: &[u8] = b"fadroma_root_state";
        pub fn get_store_rw<S: Storage>(storage: &mut S) -> Singleton<S, $State> {
            singleton(storage, CONFIG_KEY)
        }
        pub fn get_store_ro<S: Storage>(storage: &S) -> ReadonlySingleton<S, $State> {
            singleton_read(storage, CONFIG_KEY)
        }
    }
}

/// Instantiation interface.
#[macro_export] macro_rules! define_init_message {
    // if imported:
    ($_:ident, $Import:ident) => { pub use super::$Import; };
    // if defined in place:
    ($Name:ident, { $(
        $(#[$meta:meta])* $arg:ident : $type:ty
    ),* }) => {
        message!($Name { $($arg: $type),* });
    }
}

/// Query interface.
#[macro_export] macro_rules! define_q_messages {
    // if imported:
    ($_1:tt, $Import:ident, { $($_2:tt)* }) => { pub use super::$Import; };
    // if defined in place:
    ($Name:ident, { $(
        $(#[$meta:meta])* $Variant:ident ( $(
            $(#[$arg_meta:meta])* $arg:ident : $type:ty
        ),* )
    )* }) => {
        messages!($Name { $( $(#[$meta])* $Variant {$(
            $(#[$arg_meta])* $arg: $type
        ),*} )* });
    };
}

/// Transaction interface.
#[macro_export] macro_rules! define_tx_messages {
    // if imported:
    ($_1:tt, $Import:ident, { $($_2:tt)* }) => { pub use super::$Import; };
    // if defined in place:
    ($Name:ident, { $(
        $(#[$meta:meta])* $Variant:ident ( $(
            $(#[$arg_meta:meta])* $arg:ident : $type:ty
        ),* )
    )* }) => {
        messages!($Name { $( $(#[$meta])* $Variant {$(
            $(#[$arg_meta])* $arg: $type
        ),*} )* });
    };
}

/// Instatiation. Either defines or imports an `InitMsg`, and hooks up your init logic to it.
/// Function body must return the initial value of `State`.
#[macro_export] macro_rules! implement_init {
    // define the InitMsg in place:
    (
        $(#[$InitMeta:meta])* [$Init:ident]
        ($deps:ident, $env:ident, $msg:ident :{ $($field:ident : $type:ty),* }) $body:block
    ) => {
        use msg::$Init;
        $(#[$InitMeta])*
        pub fn init <S: Storage, A: Api, Q: Querier>(
            $deps: &mut Extern<S, A, Q>, $env: Env, $msg: $Init
        ) -> StdResult<InitResponse> {
            $(let $field : $type = $msg.$field;)*
            macro_rules! save_state {
                // Storing the global state of the contract with this macro
                ($global_state:expr) => { get_store_rw(&mut $deps.storage).save(&$global_state)?; }
            };
            Ok($body)
        }
    };
    // or import it from an external module:
    (
        $(#[$InitMeta:meta])* [$_:ident]
        ($deps:ident, $env:ident, $msg:ident : $InitExt:ty ) $body:block
    ) => {
        $(#[$InitMeta])*
        pub fn init <S: Storage, A: Api, Q: Querier>(
            $deps: &mut Extern<S, A, Q>, $env: Env, $msg: $InitExt
        ) -> StdResult<InitResponse> {
            // no auto-destructuring because the macro is not aware of the struct fields
            macro_rules! save_state {
                // Storing the global state of the contract with this macro
                ($global_state:expr) => { get_store_rw(&mut $deps.storage).save(&$global_state)?; }
            };
            $body;
            Ok(InitResponse::default())
        }
    };
}

/// Query implementations.
#[macro_export] macro_rules! implement_queries {
    // for external query message type, ignore the name in the brackets
    // and pass through to the next macro variantb
    (
        $State:ident, $EnumExt:ident, $_:ident
        ( $deps:ident, $state:ident, $msg:ident ) -> $Response:ident { $($bodies:tt)* }
    ) => {
        implement_queries!($State, $EnumExt ( $deps, $state, $msg ) -> $Response { $($bodies)* });
    };

    // implement queries defined in $body
    (
        $State:ident, $Enum:ident
        ( $deps:ident, $state:ident, $msg:ident ) -> $Response:ident { $(
            $(#[$meta:meta])* $Variant:ident ( $($field:ident : $type:ty),*)
            $body:tt
        )* }
    ) => {
        /// Query dispatcher.
        pub fn query <S: Storage, A: Api, Q: Querier> (
            $deps: &Extern<S, A, Q>, $msg: msg::$Enum
        ) -> StdResult<Binary> {
            let state = get_store_ro(&$deps.storage).load()?; // get snapshot of contract state
            let result = match $msg { $( // find the matching handler
                msg::$Enum::$Variant {..} => self::queries::$Variant($deps, state, $msg),
            )* };
            Ok(fadroma::scrt::cosmwasm_std::to_binary(&result?)?) // return handler result
        }
        /// Query handlers.
        mod queries {
            prelude!();
            use super::{*, msg::Response};
            // for every query message variant, define a handler 
            $(
                $(#[$meta])*
                #[allow(non_snake_case)]
                pub fn $Variant <S: Storage, A: Api, Q: Querier>(
                    $deps: &Extern<S, A, Q>, $state: $State, $msg: msg::$Enum,
                ) -> StdResult<$Response> {
                    if let super::msg::$Enum::$Variant {$($field),*} = $msg { // destructure the message
                        $body // perform user-specified actions
                    } else { unreachable!() }
                }
            )*
        }

    }
}

/// Transaction implementations
#[macro_export] macro_rules! implement_transactions {
    (   $State:ident, $Enum:ident, $_:ident
        ($deps:ident, $env:ident, $state:ident, $msg:ident) -> $Response:ident { $($bodies:tt)* }
    ) => {
        implement_transactions!($State, $Enum ($deps, $env, $state, $msg) -> $Response { $($bodies)* });
    };
    (   $State:ident, $Enum:ident
        ($deps:ident, $env:ident, $state:ident, $msg:ident) -> $Response:ident {
            $($(#[$meta:meta])* $Variant:ident ( $($arg:ident $(: $type:ty)?),* ) $body:block)*
        }
    ) => {
        /// Transaction dispatcher
        pub fn handle <S: Storage, A: Api, Q: Querier> (
            $deps: &mut Extern<S, A, Q>, $env: Env, $msg: msg::$Enum,
        ) -> StdResult<HandleResponse> {
            // pick the handler that matches the message and call it:
            match $msg { $(
                msg::$Enum::$Variant {..} => self::handle::$Variant($deps, $env, $msg),
            )* }
        }
        /// Transaction handlers
        mod handle {
            prelude!();
            use super::*;
            // shorthand for saving state
            // define a handler for every tx message variant
            $(#[allow(non_snake_case)] pub fn $Variant <S: Storage, A: Api, Q: Querier>(
                $deps: &mut Extern<S, A, Q>,
                $env:  Env,
                $msg:  msg::$Enum,
            ) -> StdResult<HandleResponse> {
                // get mutable snapshot of current state:
                let mut $state = get_store_rw(&mut $deps.storage).load()?;
                macro_rules! save_state {
                    () => { get_store_rw(&mut $deps.storage).save(&$state)?; }
                };
                if let super::msg::$Enum::$Variant {$($arg),*} = $msg {
                    // perform user-specified actions
                    $body
                } else {
                    unreachable!()
                }
            })*
        }
    };
}

/// Î» binding exposing a wrapped Rust struct to JavaScript.
///
/// Rust doesn't allow for monkey-patching
/// (we can't impl things on things that we don't own),
/// so we need to wrap each struct from the Rust API
/// in our own locally defined struct and expose that to wasm_bindgen.
///
/// From JS-land, tthe wrapped struct looks like an object
/// containing an opaque pointer to JS memory.
/// This macro also supports adding methods to the binding,
/// which methods will be exposed on the JS object.
// Macros are truly a blessing in the disguise of a curse.
//
// * `attempted to repeat an expression containing no syntax variables matched
//   as repeating at this depth` - best error message ever.
// * or `this file contains an unclosed delimiter` (but it already
//   optimized away that info by design so now we don't know where)
// * or `repetition matches empty token tree` - jeez rustc, are you
//   gonna loop back on yourself if you do that?!
#[macro_export] macro_rules! binding {
    ( $(
        $struct:ident /// the name of the resulting new binding struct
        $fields:tt    /// `(cw::WrapAStruct)` or `{define: Custom, fields: Innit}`

        $({ // if there are any functions defined below
        $( // each one will be implemented on the new struct
            $(#[$meta:meta])* // allow doc strings, marking as constructor, etc
            fn $name:ident    // single point of adding `pub` marker
            ($($args:tt)*) -> // arguments as called from JS-land
            $returns:ty       // return type is wrapped for error handling
            $body:block       // implementation of function that returns `Ok($returns)`
        )+ // end iteration over each input function
        })? // end check for presence of input functions

    )* ) => { $(
        // generate a new struct and derive the wasm_bindgen trait suite for it
        #[wasm_bindgen] pub struct $struct $fields;

        // if there are bound functions wrap em with da `impl` wrapper
        $(#[wasm_bindgen] impl $struct {
            $( // and output each one as a public bound method
            $(#[$meta])* // it's as meta as it gets...
            pub fn $name ($($args)*) -> Result<$returns, JsValue> {
                $body.map_err(|e: cw::StdError| format!("{:#?}", &e).into())
            })+ // end iteration
        })? // end conditional
    )* };
}

/// Define a smart contract
#[macro_export] macro_rules! contract {

    (
        // passed to `define_state_singleton!`
        [$State:ident]
        { $( $(#[$meta:meta])* $state_field:ident : $state_field_type:ty ),* }

        // Define the signature of the init message, how it's handled.
        //
        $(#[$InitMeta:meta])*
        [$Init:ident]
        ( $init_deps:ident, $init_env:ident, $init_msg:ident : $($init_msg_definition:tt)+
        ) $init_body:block

        // Define query messages and how they're handled:
        [$Q:ident]
        ( $q_deps:ident, $q_state:ident, $q_msg:ident $( : $ExtQ:ident)? )
        -> $QResponse:ident { $(
            $(#[$QVariantMeta:meta])* $QVariant:ident ($(
                $(#[$QVariantArgMeta:meta])*
                $q_arg:ident $(: $q_arg_type:ty)?
            ),*) $q_body:tt
        )* }

        // Define possible responses:
        [$Response:ident] {
        $( $(#[$response_meta:meta])* $ResponseMsg:ident { $($resp_field:ident : $resp_field_type:ty),* } )* }

        // Define transaction messages and how they're handled:
        [$TX:ident]
        ( $tx_deps:ident, $tx_env:ident, $tx_state:ident, $tx_msg:ident $( : $ExtTX:ident)? )
        -> $TXResponse:ident { $(
            $(#[$TXVariantMeta:meta])* $TXVariant:ident ($(
                $(#[$TXVariantArgMeta:meta])*
                $tx_arg:ident $(: $tx_arg_type:ty)?
            ),*) $tx_body:tt
        )* }

    ) => {

        prelude!();

        /// WASM entry points.
        // Similar in spirit to [`create_entry_points`](https://docs.rs/cosmwasm-std/0.10.1/src/cosmwasm_std/entry_points.rs.html#49),
        // but doesn't need the implementation to be in a sibling module (the `super::contract` on L65)
        // TODO custom `migrate` for SecretNetwork
        #[cfg(all(target_arch = "wasm32", not(feature = "browser")))]
        mod wasm {
            //use super::contract;
            use fadroma::scrt::cosmwasm_std::{
                ExternalStorage as Storage, ExternalApi as Api, ExternalQuerier as Querier,
                do_init, do_handle, do_query
            };
            #[no_mangle] extern "C" fn init (env_ptr: u32, msg_ptr: u32) -> u32 {
                do_init(&super::init::<Storage, Api, Querier>, env_ptr, msg_ptr)
            }
            #[no_mangle] extern "C" fn handle (env_ptr: u32, msg_ptr: u32) -> u32 {
                do_handle(&super::handle::<Storage, Api, Querier>, env_ptr, msg_ptr)
            }
            #[no_mangle] extern "C" fn query (msg_ptr: u32) -> u32 {
                do_query(&super::query::<Storage, Api, Querier>, msg_ptr,)
            }
            // Other C externs like cosmwasm_vm_version_1, allocate, deallocate are available
            // automatically because we `use cosmwasm_std`.
        }

        #[cfg(all(target_arch = "wasm32", feature = "browser"))]
        mod wasm {
            use wasm_bindgen::prelude::{wasm_bindgen, JsValue};
            use fadroma::scrt::cosmwasm_std as cw;
            use fadroma::scrt::contract::binding;

            // TODO: minimal implementations of these
            #[wasm_bindgen] #[derive(Copy, Clone)] pub struct Api {}
            impl cw::Api for Api {
                fn canonical_address (&self, addr: &cw::HumanAddr) -> cw::StdResult<cw::CanonicalAddr> {
                    Ok(cw::CanonicalAddr(cw::Binary(Vec::from(addr.as_str()))))
                }
                fn human_address (&self, addr: &cw::CanonicalAddr) -> cw::StdResult<cw::HumanAddr> {
                    let trimmed: Vec<u8> = addr.as_slice().iter().cloned().filter(|&x| x != 0).collect();
                    // decode UTF-8 bytes into string
                    Ok(cw::HumanAddr(String::from_utf8(trimmed).map_err(cw::StdError::invalid_utf8)?))
                }
            }

            #[wasm_bindgen] pub struct Querier {}
            impl cw::Querier for Querier {
                fn raw_query (&self, bin_request: &[u8]) -> cw::QuerierResult {
                    Ok(cw::to_binary(&[] as &[u8]))
                }
            }

            //impl From<cw::StdError> for StdError {
                //fn from (err: cw::StdError) -> Self {
                    //Self(format!("bound error {:#?}", &err).into())
                //}
            //}

            binding! {

                //StdError(String)

                HumanAddr(cw::HumanAddr)

                CanonicalAddr(cw::CanonicalAddr)

                Env(cw::Env) {
                    #[wasm_bindgen(constructor)] fn new (height: u64) -> Env {
                        Ok(Env(cw::Env {
                            block: cw::BlockInfo {
                                height,
                                time: height * 5,
                                chain_id: "".into()
                            },
                            message: cw::MessageInfo {
                                sender:     cw::HumanAddr::from(""),
                                sent_funds: vec![]
                            },
                            contract: cw::ContractInfo {
                                address: cw::HumanAddr::from("")
                            },
                            contract_key: Some("".into()),
                            contract_code_hash: "".into()
                        }))
                    }
                }

                InitMsg(super::msg::$Init) {
                    #[wasm_bindgen(constructor)] fn new (json: &[u8]) -> InitMsg {
                        cw::from_slice(json).map(|msg|InitMsg(msg))
                    }
                }

                InitResponse(cw::InitResponse)

                HandleMsg(super::msg::$TX) {
                    #[wasm_bindgen(constructor)] fn new (json: &[u8]) -> HandleMsg {
                        cw::from_slice(json).map(|msg|HandleMsg(msg))
                    }
                }

                HandleResponse(cw::HandleResponse)

                QueryMsg(super::msg::$Q) {
                    #[wasm_bindgen(constructor)] fn new (json: &[u8]) -> QueryMsg {
                        cw::from_slice(json).map(|msg|QueryMsg(msg))
                    }
                }

                QueryResponse(super::msg::$Response)

                Contract(cw::Extern<cw::MemoryStorage, Api, Querier> /* ha! */) {
                    #[wasm_bindgen(constructor)] fn new () -> Contract {
                        Ok(Self(cw::Extern {
                            storage:  cw::MemoryStorage::default(),
                            api:      Api {},
                            querier:  Querier {}
                        }))
                    }
                    fn init (&mut self, env: Env, msg: InitMsg) -> InitResponse {
                        super::init(&mut self.0, env.0, msg.0).map(|res|InitResponse(res))
                    }
                    fn handle (&mut self, env: Env, msg: HandleMsg) -> HandleResponse {
                        super::handle(&mut self.0, env.0, msg.0).map(|res|HandleResponse(res))
                    }
                    fn query (&self, msg: QueryMsg) -> QueryResponse {
                        match super::query(&self.0, msg.0) {
                            Ok(res) => cw::from_binary(&res).map(|res|QueryResponse(res)),
                            Err(e) => Err(e)
                        }
                    }
                }

            }

        }

        /// This contract's on-chain API.
        pub mod msg {
            // The argument sets of the {Init,Query,Handle}Msg handlers
            // are used to automatically generate the corresponding
            // protocol messages.
            // * This is why the @Q/@TX/@Response sub-sections are not just passed in as opaque `tt`s
            // * Only responses can't be inferred and need to be pre-defined.
            // * Although, with some more macro trickery, they could be defined in place
            //   (e.g. the return types of $Q handlers could be defined as
            //   `-> Foo { field: type }` and then populated with `return Self { field: value }`
            // * Let's revisit this once some we have some more examples of custom responses
            //
            prelude!();

            use super::*;

            define_init_message!($Init, $($init_msg_definition)+);

            define_q_messages!($Q, $($ExtQ,)? {
                $( $(#[$QVariantMeta])* $QVariant ($(
                    $(#[$QVariantArgMeta])*
                    $q_arg $(: $q_arg_type)?
                ),*))*
            });

            define_tx_messages!($TX, $($ExtTX,)? {
                $( $(#[$TXVariantMeta])* $TXVariant ($(
                    $(#[$TXVariantArgMeta])*
                    $tx_arg $(: $tx_arg_type)?),*
                ))*
            });

            messages!($Response { $(
                $(#[$response_meta])* $ResponseMsg {$($resp_field: $resp_field_type),*}
            )* });
        }

        /// Implementations
        //use msg::{$Init,$Q,$TX,$Response};

        define_state_singleton! {
            $State { $( $(#[$meta])* $state_field : $state_field_type ),* }
        }

        implement_init! {
            $(#[$InitMeta])* [$Init]
            ($init_deps, $init_env, $init_msg : $($init_msg_definition)+) $init_body
        }

        implement_queries! {
            $State, $($ExtQ,)? $Q ($q_deps, $q_state, $q_msg) -> $QResponse { $(
                $(#[$QVariantMeta])* $QVariant
                ($($q_arg $(: $q_arg_type)?),*) $q_body
            )* }
        }

        implement_transactions! {
            $State, $($ExtTX,)? $TX ($tx_deps, $tx_env, $tx_state, $tx_msg) -> $TXResponse { $(
                $(#[$TXVariantMeta])* $TXVariant
                ($( $tx_arg $(: $tx_arg_type)?),*) $tx_body
            )* }
        }

    };

}

// TODO proposed action against the triple generic:
// scrt-contract automatically aliases `storage`, `api`,
// and `querier` (also maybe the contents of `env`?)
// so that it becomes less verbose to pass just the ones you use
// (...that, or let's just give contracts a `self` already?)
