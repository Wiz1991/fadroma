import { writeFile, resolve } from '@fadroma/utilities/sys.js'

/** Interface to a contract instance.
 * Can be subclassed with schema to auto-generate methods
 * TODO connect to existing contract */
export default class SecretNetworkContract {

  constructor (fields={}) {
    Object.assign(this, fields)
  }

  /**Get the path to the upload receipt for the contract's code.
   */
  get receiptPath () { return resolve(this.network.instances, `${this.label}.json`) }

  /**Get an interface to the network where the contract is deployed.
   */
  get network () { return this.agent.network }

  /**Get the address of the contract.
   */
  get address () { return this.contractAddress }

  /**Tell an agent to instantiate this contract from codeId, label, and initMsg.
   */
  static async init ({ agent, codeId, label, initMsg } = {}) {
    const receipt = await agent.instantiate({codeId, label, initMsg})
    const instance = new this({ agent, ...receipt })
    await writeFile(instance.receiptPath, JSON.stringify(receipt, null, 2), 'utf8')
    return instance
  }

  /**Query the contract.
   */
  query = (method = '', args = {}, agent = this.agent) =>
    agent.query(this, method, args)

  /**Execute a contract transaction.
   */
  execute = (method = '', args = {}, agent = this.agent) =>
    agent.execute(this, method, args)

  /** Create subclass with methods based on the schema
   * TODO: validate schema and req/res arguments (with `ajv`?)
   */
  static withSchema = (schema={}) =>
    extendWithSchema(this, schema)
}

/** Extend SecretNetworkContract class
 * with methods automatically generated
 * from provided JSON schema. */
export function extendWithSchema (SecretNetworkContract, schema) {

  return class SecretNetworkContractWithSchema extends SecretNetworkContract {
    // read-only: the parsed schema
    static get schema () { return schema }
    // read-only: the queries generated from the schema
    get q () {
      return methodsFromSchema(this, this.constructor.schema.queryMsg, (self, method) => ({
        async [method] (args, agent = self.agent) { return await self.query(method, args, agent) }
      }))
    }
    // read-only: the transactions generated from the schema
    get tx () {
      return methodsFromSchema(this, this.constructor.schema.handleMsg, (self, method) => ({
        async [method] (args, agent = self.agent) { return await self.execute(method, args, agent) }
      }))
    }
  }

  // TODO: memoize this, so that methods aren't regenerated until the schema updates
  // TODO: generate TypeScript types from autogenerated method lists and/or from schema
  function methodsFromSchema (self, schema, getWrappedMethod) {
    if (!schema) return null
    return schema.anyOf.reduce((methods, methodSchema)=>{
      const {description, required:[methodName]} = methodSchema
      const methodWrapper = getWrappedMethod(self, methodName)
      methodWrapper[methodName].description = description
      methodWrapper[methodName] = methodWrapper[methodName].bind(self)
      return Object.assign(methods, methodWrapper)
    }, {})
  }

}
