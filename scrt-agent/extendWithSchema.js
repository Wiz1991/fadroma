/** Extend SecretNetworkContract class
 * with methods automatically generated
 * from provided JSON schema. */
export default function extendWithSchema (
  SecretNetworkContract,
  schema
) {

  return class SecretNetworkContractWithSchema extends SecretNetworkContract {

    /** Fixes TypeScript's lack of static inheritance */
    static init = (...args) =>
      super.init(...args)

    // read-only: the parsed schema
    static get schema () { return schema }
    // read-only: the queries generated from the schema
    get q () {
      return agent => methodsFromSchema(
        this, this.constructor.schema.queryMsg, (instance, method) => ({
          async [method] (args) { return await instance.query(method, args, agent) }
        })
      )
    }
    // read-only: the transactions generated from the schema
    get tx () {
      return agent => methodsFromSchema(
        this, this.constructor.schema.handleMsg, (instance, method) => ({
          async [method] (args) { return await instance.execute(method, args, agent) }
        })
      )
    }
  }

  // TODO: memoize this, so that methods aren't regenerated until the schema updates
  // TODO: generate TypeScript types from autogenerated method lists and/or from schema
  function methodsFromSchema (instance, messages, getWrappedMethod) {
    if (!messages) return null
    return messages.anyOf.reduce((methods, methodSchema)=>{
      const {description, required:[methodName]} = methodSchema
      const methodWrapper = getWrappedMethod(instance, methodName)
      methodWrapper[methodName].description = description
      methodWrapper[methodName] = methodWrapper[methodName].bind(instance)
      return Object.assign(methods, methodWrapper)
    }, {})
  }

}
