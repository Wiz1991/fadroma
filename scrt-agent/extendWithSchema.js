/** Extend SecretNetworkContract class
 * with methods automatically generated
 * from provided JSON schema. */
export default function extendWithSchema (
  SecretNetworkContract,
  { queryMsg, handleMsg }
) {

  return class SecretNetworkContractWithSchema extends SecretNetworkContract {

    /* Returns a function binding the executing agent
     * to a collection of possible queries */
    get q () {
      return (agent = this.agent) =>
        methodsFromSchema(this, queryMsg, (instance, method) => ({
          async [method] (args) {
            return await instance.query(method, args, agent)
          }
        }))
    }

    /* Returns a function binding the executing agent
     * to a collection of possible transactions */
    get tx () {
      return (agent = this.agent) =>
        methodsFromSchema(this, handleMsg, (instance, method) => ({
          async [method] (args) {
            return await instance.execute(method, args, agent)
          }
        }))
    }

  }

  // TODO: memoize this, so that methods aren't regenerated until the schema updates
  // TODO: generate TypeScript types from autogenerated method lists and/or from schema
  function methodsFromSchema (instance, messages, getWrappedMethod) {
    if (!messages) return null
    return messages.anyOf.reduce((methods, methodSchema) => {
      // Schema has different objects in it, this one will handle the "string" object
      if (methodSchema.type === 'string') {
        // "string" object might have different variants, but for now, we will handle only the enum one 
        // by checking that the "enum" attribute is an Array, each option from that array corresponds 
        // to a single callable method that has no parameters defined within that enum variant
        //
        // NOTE: This should not be mistaken by an entire enum like "QueryMsg" from which the whole schema 
        // file is created, this is only a compact way schema collects those variants which don't have params (are not objects)
        if (Array.isArray(methodSchema.enum)) {
          for (const m of methodSchema.enum) {
            const methodWrapper = getWrappedMethod(instance, m)
            methodWrapper[m].description = ""
            methodWrapper[m] = methodWrapper[m].bind(instance)
            methods = Object.assign(methods, methodWrapper)
          }

          return methods
        }
      }
      // ...this one will handle the "object" object
      else if (methodSchema.type === "object") {
        const { description, required: [methodName] } = methodSchema
        const methodWrapper = getWrappedMethod(instance, methodName)
        methodWrapper[methodName].description = description
        methodWrapper[methodName] = methodWrapper[methodName].bind(instance)
        return Object.assign(methods, methodWrapper)
      }
      else {
        return methods
      }
    }, {})
  }
}
